---
title: "Predicting Color Classes from 2D Coordinates Using a Neural Network"
format:
  html:
    code-fold: true
jupyter: python3
---

## Project Steps

- **Data Preparation**: Create arrays of 2D coordinates (`x`, `y`) and corresponding color labels, and split data into training and test sets.
- **Model Creation**: Use PyTorch to create a neural network for multi-class classification.
- **Training**: Train the model for multiple epochs.
- **Evaluation**: Evaluate the model using the test data and predict color classes.
- **Visualization**: Generate a grid of points, predict color classes, and create a scatter plot to visualize the results.

This project demonstrates 2D spatial classification using a neural network in PyTorch.

```{python}
import torch
from matplotlib import pyplot
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
from collections import Counter
torch.__version__
```

## Data Generation

```{python}
color_map = ["red", "blue", "green"]

num_points = 3000
square_size = 800
x = torch.rand(num_points) * square_size
y = torch.rand(num_points) * square_size
color_indices = torch.randint(0, len(color_map), (num_points,))
x -= square_size / 2
y -= square_size / 2
colors = []


def prob_fn(val, zero_val):
    return val * (-1 / zero_val) + 1


for i in range(num_points):
    x0 = x[i]
    y0 = y[i]
    rand = torch.rand(1).item()

    origin_dist = torch.hypot(x0, y0)
    circle_start = 300
    if origin_dist > circle_start and rand > prob_fn(origin_dist - circle_start, 100) and not (x0 > 0 and y0 < 0):
        colors.append(2)
        continue

    eval_f = x0 * x0 / 100
    dist = abs(eval_f - y0)

    if rand > prob_fn(dist, 130):
        colors.append(0)
    else:
        colors.append(1)
```

```{python}
pyplot.scatter(x, y, c=[color_map[i] for i in colors])
pyplot.xlabel("X-axis")
pyplot.ylabel("Y-axis")
pyplot.show()
```

```{python}
X = torch.stack((x, y), dim=1)
print(X)
```

```{python}
y_labels = torch.tensor(colors)

print(y_labels, Counter(y_labels.tolist()))
```

## Model Creation

```{python}
class ColorPredictionModel(nn.Module):
    def __init__(self, input_size, hidden_size, num_classes):
        super(ColorPredictionModel, self).__init__()

        # TODO: Maybe make this model more robust.
        # And if it improves, decrease the amount of epochs.

        self.layer1 = nn.Linear(input_size, hidden_size)
        self.layer2 = nn.Linear(hidden_size, hidden_size)
        self.layer3 = nn.Linear(hidden_size, hidden_size)
        self.output = nn.Linear(hidden_size, num_classes)

    def forward(self, x):
        x = torch.relu(self.layer1(x))
        x = torch.relu(self.layer2(x))
        x = torch.relu(self.layer3(x))
        x = self.output(x)
        return x
```

## Training

```{python}
def split_data(X, y_labels):
    indices = torch.randperm(X.size(0))
    train_size = int(0.8 * X.size(0))
    test_size = X.size(0) - train_size
    # TODO: Maybe this is wrong, since the variable is unused.

    train_indices = indices[:train_size]
    test_indices = indices[train_size:]

    return X[train_indices], X[test_indices], y_labels[train_indices], y_labels[test_indices]


X_train, X_test, y_train, y_test = split_data(X, y_labels)
```

```{python}
train_dataset = TensorDataset(X_train, y_train)
test_dataset = TensorDataset(X_test, y_test)

train_loader = DataLoader(train_dataset, batch_size=2, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=2, shuffle=False)

model = ColorPredictionModel(input_size=2, hidden_size=64, num_classes=3)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

epochs = 100
for epoch in range(epochs):
    model.train()
    running_loss = 0.0
    for batch_X, batch_y in train_loader:
        optimizer.zero_grad()
        outputs = model(batch_X)
        loss = criterion(outputs, batch_y)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()

    if (epoch + 1) % 10 == 0:
        print(
            f"Epoch [{epoch+1}/{epochs}], Loss: {running_loss/len(train_loader):.4f}")
```

## Model Testing and Visualization

```{python}
model.eval()
correct = 0
total = 0
with torch.no_grad():
    for batch_X, batch_y in test_loader:
        outputs = model(batch_X)
        _, predicted = torch.max(outputs, 1)
        total += batch_y.size(0)
        correct += (predicted == batch_y).sum().item()

accuracy = 100 * correct / total
print(f'Accuracy on test data: {accuracy:.2f}%')
```

```{python}
x_range = torch.linspace(-400, 400, 200)
y_range = torch.linspace(-400, 400, 200)

x_grid, y_grid = torch.meshgrid(x_range, y_range, indexing="ij")

grid_points = torch.stack([x_grid.flatten(), y_grid.flatten()], dim=1)

model.eval()

with torch.no_grad():
    outputs = model(grid_points)
    predicted_classes = torch.argmax(outputs, dim=1)

pyplot.figure(figsize=(8, 8))
pyplot.scatter(x_grid, y_grid, c=[color_map[i] for i in predicted_classes])
pyplot.show()
```
